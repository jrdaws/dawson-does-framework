// src/dd/init.mjs
/**
 * Initialize an existing project with framework tooling
 */

import fs from 'node:fs'
import path from 'node:path'

/**
 * Parse init command flags
 * @param {string[]} args - Command arguments
 * @returns {object} Parsed flags
 */
export function parseInitFlags(args) {
  const flags = {
    cursor: false,
    name: null,
    force: false,
    dryRun: false,
    git: true,
  }

  for (let i = 0; i < args.length; i++) {
    const arg = args[i]
    if (arg === '--cursor') {
      flags.cursor = true
    } else if (arg === '--force') {
      flags.force = true
    } else if (arg === '--dry-run') {
      flags.dryRun = true
    } else if (arg === '--no-git') {
      flags.git = false
    } else if (arg === '--name' && i + 1 < args.length) {
      flags.name = args[i + 1]
      i++
    }
  }

  return flags
}

/**
 * Check if directory is already initialized
 * @param {string} dir - Directory to check
 * @returns {boolean} True if .dd directory exists
 */
export function isInitialized(dir) {
  const ddDir = path.join(dir, '.dd')
  return fs.existsSync(ddDir)
}

/**
 * Create manifest.json content for init
 * @param {string} projectName - Name of the project
 * @param {string} projectDir - Project directory path
 * @returns {object} Manifest object
 */
export function createInitManifest(projectName, projectDir) {
  return {
    schemaVersion: 1,
    projectName,
    template: 'custom',
    frameworkVersion: null,
    initializedAt: new Date().toISOString(),
    initializedFrom: 'framework init',
    projectDir,
  }
}

/**
 * Create default config.json for init
 * @returns {object} Config object
 */
export function createDefaultConfig() {
  return {
    plan: 'free',
    featureOverrides: {},
    afterInstall: 'prompt',
  }
}

/**
 * Detect package.json and return project info
 * @param {string} dir - Directory to check
 * @returns {object|null} Project info or null
 */
export function detectProjectInfo(dir) {
  const packageJsonPath = path.join(dir, 'package.json')

  if (!fs.existsSync(packageJsonPath)) {
    return null
  }

  try {
    const content = fs.readFileSync(packageJsonPath, 'utf8')
    const pkg = JSON.parse(content)

    return {
      name: pkg.name || path.basename(dir),
      version: pkg.version || '0.0.0',
      description: pkg.description || '',
      hasNext: !!(pkg.dependencies?.next || pkg.devDependencies?.next),
      hasReact: !!(pkg.dependencies?.react || pkg.devDependencies?.react),
      hasTypeScript: fs.existsSync(path.join(dir, 'tsconfig.json')),
    }
  } catch {
    return null
  }
}

/**
 * Create .dd directory structure
 * @param {string} dir - Project directory
 * @param {string} projectName - Project name
 * @returns {void}
 */
export function createDdStructure(dir, projectName) {
  const ddDir = path.join(dir, '.dd')
  fs.mkdirSync(ddDir, { recursive: true })

  // Create manifest.json
  const manifest = createInitManifest(projectName, dir)
  fs.writeFileSync(
    path.join(ddDir, 'manifest.json'),
    JSON.stringify(manifest, null, 2),
    'utf8'
  )

  // Create config.json
  const config = createDefaultConfig()
  fs.writeFileSync(
    path.join(ddDir, 'config.json'),
    JSON.stringify(config, null, 2),
    'utf8'
  )

  // Create .gitkeep to ensure directory is tracked
  fs.writeFileSync(path.join(ddDir, '.gitkeep'), '', 'utf8')
}

/**
 * Generate .cursorrules for existing project
 * @param {object} projectInfo - Project information
 * @returns {string} Cursor rules content
 */
export function generateInitCursorRules(projectInfo) {
  const sections = []

  sections.push(`# Cursor Rules for ${projectInfo.name}`)
  sections.push('# Generated by dawson-does-framework init')
  sections.push('')

  sections.push('## Project Context')
  sections.push('')
  sections.push(`- **Project**: ${projectInfo.name}`)
  if (projectInfo.description) {
    sections.push(`- **Description**: ${projectInfo.description}`)
  }
  sections.push(`- **Initialized**: ${new Date().toISOString().split('T')[0]}`)
  sections.push('')

  sections.push('## Tech Stack')
  sections.push('')
  const stack = []
  if (projectInfo.hasNext) stack.push('**Framework**: Next.js')
  if (projectInfo.hasReact) stack.push('**UI Library**: React')
  if (projectInfo.hasTypeScript) stack.push('**Language**: TypeScript')

  if (stack.length > 0) {
    stack.forEach(item => sections.push(`- ${item}`))
  } else {
    sections.push('- **Custom stack** - see package.json')
  }
  sections.push('')

  sections.push('## Development Guidelines')
  sections.push('')
  sections.push('### Code Style')
  if (projectInfo.hasTypeScript) {
    sections.push('- Use TypeScript for type safety')
    sections.push('- Define interfaces for complex data structures')
  }
  sections.push('- Follow existing code patterns in the codebase')
  sections.push('- Use descriptive variable and function names')
  sections.push('- Add comments for complex logic')
  sections.push('')

  sections.push('### File Organization')
  sections.push('- Keep files organized by feature or domain')
  sections.push('- Colocate related files (components, tests, styles)')
  sections.push('- Use consistent naming conventions')
  sections.push('')

  sections.push('## Framework Integration')
  sections.push('')
  sections.push('This project is managed with dawson-does-framework:')
  sections.push('- Run `framework doctor` to check project health')
  sections.push('- Use `framework deploy` to deploy to production')
  sections.push('- See `.dd/manifest.json` for framework metadata')
  sections.push('')

  return sections.join('\n')
}

/**
 * Generate START_PROMPT.md for existing project
 * @param {object} projectInfo - Project information
 * @returns {string} Start prompt content
 */
export function generateInitStartPrompt(projectInfo) {
  const sections = []

  sections.push(`# ${projectInfo.name}`)
  sections.push('')

  if (projectInfo.description) {
    sections.push(projectInfo.description)
    sections.push('')
  }

  sections.push('## Getting Started')
  sections.push('')
  sections.push('This project has been initialized with dawson-does-framework.')
  sections.push('')

  sections.push('### Development')
  sections.push('')
  sections.push('```bash')
  sections.push('# Install dependencies')
  sections.push('npm install')
  sections.push('')
  sections.push('# Run development server')
  sections.push('npm run dev')
  sections.push('```')
  sections.push('')

  sections.push('### Framework Commands')
  sections.push('')
  sections.push('```bash')
  sections.push('# Check project health')
  sections.push('framework doctor')
  sections.push('')
  sections.push('# Deploy to production')
  sections.push('framework deploy --prod')
  sections.push('')
  sections.push('# View all commands')
  sections.push('framework --help')
  sections.push('```')
  sections.push('')

  sections.push('## Project Structure')
  sections.push('')
  sections.push('```')
  sections.push('.')
  sections.push('├── .dd/                # Framework metadata')
  sections.push('│   ├── manifest.json  # Project metadata')
  sections.push('│   └── config.json    # Framework configuration')
  sections.push('├── package.json        # Dependencies')
  if (projectInfo.hasTypeScript) {
    sections.push('├── tsconfig.json       # TypeScript config')
  }
  sections.push('└── ...                 # Your project files')
  sections.push('```')
  sections.push('')

  sections.push('## Next Steps')
  sections.push('')
  sections.push('1. Review `.cursorrules` for AI coding guidelines')
  sections.push('2. Run `framework doctor` to verify setup')
  sections.push('3. Start building your features')
  sections.push('4. Deploy with `framework deploy` when ready')
  sections.push('')

  sections.push('---')
  sections.push('')
  sections.push('Generated by dawson-does-framework')
  sections.push('')

  return sections.join('\n')
}
