# Token Efficiency Optimization Task

**Priority**: P0 - Cost Reduction
**Agent**: Documentation Agent (with CLI Agent assist)
**Estimated Savings**: 50-70% reduction in per-session token consumption

---

## Background

Current architecture consumes 12,500-20,000 tokens per session just for bootstrap overhead:
- Memory files: 6-38KB each (growing unbounded)
- Duplicate governance content across CLAUDE.md, .cursorrules, AGENT_CONTEXT.md
- Heavy bootstrap runs even for simple tasks

This task implements three optimizations to reduce costs.

---

## Task 1: Memory Rotation System

### Goal
Keep memory files under 10KB by archiving old sessions.

### Implementation

**Create `scripts/rotate-memory.sh`:**

```bash
#!/bin/bash
# Memory Rotation Script - Keep memory files lean
# Usage: ./scripts/rotate-memory.sh [MAX_SESSIONS]

MAX_SESSIONS=${1:-5}
MEMORY_DIR="prompts/agents/memory"
ARCHIVE_BASE="output/agents"

echo "üîÑ Rotating memory files (keeping last $MAX_SESSIONS sessions)..."

for file in "$MEMORY_DIR"/*_MEMORY.md; do
  [ -f "$file" ] || continue
  
  filename=$(basename "$file")
  agent_name=$(echo "$filename" | sed 's/_MEMORY.md//' | tr '[:upper:]' '[:lower:]')
  archive_dir="$ARCHIVE_BASE/$agent_name/logs"
  
  # Get file size
  size=$(wc -c < "$file" | tr -d ' ')
  
  # Only rotate if > 15KB
  if [ "$size" -gt 15000 ]; then
    echo "  üìÅ $filename ($size bytes) - rotating..."
    
    # Create archive if needed
    mkdir -p "$archive_dir"
    
    # Archive full file with timestamp
    timestamp=$(date +%Y%m%d-%H%M)
    cp "$file" "$archive_dir/memory-archive-$timestamp.md"
    
    # Keep header (everything before "## Session History") + last N sessions
    # Use awk to extract header and last N session blocks
    awk -v max="$MAX_SESSIONS" '
      /^## Session History/ { in_history = 1 }
      /^## Session:/ || /^---$/ && in_history { 
        session_count++
        if (session_count > 0) sessions[session_count] = ""
      }
      in_history { 
        if (session_count > 0) sessions[session_count] = sessions[session_count] $0 "\n"
      }
      !in_history { header = header $0 "\n" }
      END {
        print header
        print "## Session History (Rotated - Last " max " Sessions)\n"
        start = session_count - max + 1
        if (start < 1) start = 1
        for (i = start; i <= session_count; i++) {
          print sessions[i]
        }
      }
    ' "$file" > "${file}.tmp" && mv "${file}.tmp" "$file"
    
    new_size=$(wc -c < "$file" | tr -d ' ')
    echo "    ‚úÖ Reduced: $size ‚Üí $new_size bytes"
  else
    echo "  ‚úì $filename ($size bytes) - OK"
  fi
done

echo "‚úÖ Memory rotation complete"
```

**Make executable:**
```bash
chmod +x scripts/rotate-memory.sh
```

**Add to pre-commit hook or run weekly:**
```bash
# In .husky/pre-commit or manually
./scripts/rotate-memory.sh 5
```

### Archive Retention Policy

Rotated memory content is saved to `output/agents/[agent]/logs/`. Manage these archives with this retention schedule:

| Archive Age | Action | Automation |
|-------------|--------|------------|
| 0-7 days | Keep full `.md` files | None needed |
| 7-30 days | Compress to `.md.gz` | Weekly cron |
| 30-90 days | Move to `output/shared/archive/memory/` | Monthly |
| 90+ days | **Manual review required** | Flag for human review |

**Important**: Memory archives are NEVER auto-deleted. Files older than 90 days are flagged for manual review but preserved until explicitly removed by a human.

**Create `scripts/manage-memory-archives.sh`:**

```bash
#!/bin/bash
# Memory Archive Management - Compress old archives, flag for review
# Usage: ./scripts/manage-memory-archives.sh

ARCHIVE_BASE="output/agents"
SHARED_ARCHIVE="output/shared/archive/memory"
REVIEW_FILE="output/shared/archive/memory/NEEDS_REVIEW.txt"

echo "üì¶ Managing memory archives..."

# Create shared archive if needed
mkdir -p "$SHARED_ARCHIVE"

# Process each agent's logs
for agent_dir in "$ARCHIVE_BASE"/*/logs; do
  [ -d "$agent_dir" ] || continue
  agent_name=$(basename "$(dirname "$agent_dir")")
  
  for archive in "$agent_dir"/memory-archive-*.md; do
    [ -f "$archive" ] || continue
    
    filename=$(basename "$archive")
    # Extract date from filename (memory-archive-YYYYMMDD-HHMM.md)
    archive_date=$(echo "$filename" | grep -oE '[0-9]{8}')
    
    if [ -z "$archive_date" ]; then
      continue
    fi
    
    # Calculate age in days
    archive_epoch=$(date -j -f "%Y%m%d" "$archive_date" "+%s" 2>/dev/null || date -d "$archive_date" "+%s" 2>/dev/null)
    now_epoch=$(date "+%s")
    age_days=$(( (now_epoch - archive_epoch) / 86400 ))
    
    if [ "$age_days" -gt 90 ]; then
      # Flag for manual review (DO NOT DELETE)
      echo "  ‚ö†Ô∏è  $agent_name/$filename ($age_days days) - flagged for review"
      echo "[$agent_name] $filename - $age_days days old - $(date)" >> "$REVIEW_FILE"
      # Move to shared archive for centralized review
      mkdir -p "$SHARED_ARCHIVE/$agent_name"
      mv "$archive" "$SHARED_ARCHIVE/$agent_name/"
      
    elif [ "$age_days" -gt 30 ]; then
      # Move to shared archive (keep uncompressed for easy access)
      echo "  üìÅ $agent_name/$filename ($age_days days) - moving to shared archive"
      mkdir -p "$SHARED_ARCHIVE/$agent_name"
      mv "$archive" "$SHARED_ARCHIVE/$agent_name/"
      
    elif [ "$age_days" -gt 7 ]; then
      # Compress in place
      if [ ! -f "${archive}.gz" ]; then
        echo "  üóúÔ∏è  $agent_name/$filename ($age_days days) - compressing"
        gzip -k "$archive" && rm "$archive"
      fi
    else
      echo "  ‚úì $agent_name/$filename ($age_days days) - keeping"
    fi
  done
done

# Report files needing review
if [ -f "$REVIEW_FILE" ]; then
  review_count=$(wc -l < "$REVIEW_FILE" | tr -d ' ')
  echo ""
  echo "üìã $review_count archives need manual review"
  echo "   See: $REVIEW_FILE"
  echo "   Location: $SHARED_ARCHIVE/"
fi

echo "‚úÖ Archive management complete"
```

**Make executable:**
```bash
chmod +x scripts/manage-memory-archives.sh
```

**Run monthly or as needed:**
```bash
./scripts/manage-memory-archives.sh
```

### Archive Structure After Rotation

```
output/
‚îú‚îÄ‚îÄ agents/
‚îÇ   ‚îî‚îÄ‚îÄ [agent]/
‚îÇ       ‚îî‚îÄ‚îÄ logs/
‚îÇ           ‚îú‚îÄ‚îÄ memory-archive-20251225-1200.md      # < 7 days (full)
‚îÇ           ‚îî‚îÄ‚îÄ memory-archive-20251220-0900.md.gz   # 7-30 days (compressed)
‚îî‚îÄ‚îÄ shared/
    ‚îî‚îÄ‚îÄ archive/
        ‚îî‚îÄ‚îÄ memory/
            ‚îú‚îÄ‚îÄ NEEDS_REVIEW.txt                      # Files > 90 days
            ‚îú‚îÄ‚îÄ auditor/
            ‚îÇ   ‚îî‚îÄ‚îÄ memory-archive-20251001-1500.md  # > 30 days (moved)
            ‚îî‚îÄ‚îÄ cli/
                ‚îî‚îÄ‚îÄ memory-archive-20250915-0800.md  # > 90 days (flagged)
```

### How to Review Old Archives

When `NEEDS_REVIEW.txt` has entries:

1. Check the file: `cat output/shared/archive/memory/NEEDS_REVIEW.txt`
2. Review flagged archives for any critical patterns/insights
3. Extract important learnings to `docs/lessons-learned/` if valuable
4. Delete archives only after confirming no critical info: `rm [file]`
5. Clear reviewed entries from NEEDS_REVIEW.txt

**Memory archives are preserved indefinitely until manual deletion.**

---

## Task 2: Slim Bootstrap (Default) + [full] Override

### Goal
Make lightweight bootstrap the DEFAULT. Only run full bootstrap when explicitly requested with `[full]`.

### Implementation

**Replace `.cursorrules` with this optimized version:**

```markdown
# Dawson-Does Framework - Cursor Rules
# Governance Version: 3.0 | Optimized for Token Efficiency

---

## Bootstrap Mode (SLIM by Default)

**SLIM MODE (Default)**: Fast, efficient - skip heavy reads
**FULL MODE**: Use `[full]` prefix for complex/multi-step tasks

### Slim Bootstrap (Runs Automatically)

Your FIRST response should:

1. **Quick Sync** (1 command):
   ```bash
   git pull origin main --quiet && git status --short
   ```

2. **Brief Acknowledgment** (3 lines max):
   ```
   ‚úì Governance 3.0 | Export-first | No protected file deletion
   ‚úì Mode: SLIM (use [full] for heavy tasks)
   Proceeding with task...
   ```

3. **Proceed immediately with user's request**

**DO NOT read** in slim mode:
- AGENT_CONTEXT.md (you know the rules)
- Memory files (unless resuming work)
- PROJECT_PRIORITIES.md (unless checking priorities)
- MINDFRAME.md (unless certifying)

### Full Bootstrap (Only When Requested)

If user message starts with `[full]`:

1. Run complete sync check
2. Read AGENT_CONTEXT.md
3. Read memory file for your role
4. Read PROJECT_PRIORITIES.md
5. Check inbox for pending tasks
6. Then proceed with task

**Trigger phrases for full mode:**
- `[full]` - explicit trigger
- "resume previous work" - needs memory
- "check my inbox" - needs file reads
- "what's the priority" - needs priorities file

---

## Core Rules (Always Apply)

### Philosophy
- Export-first: Everything for local ownership
- Zero lock-in: Platform optional after export

### Code Style
- JavaScript (.mjs): No semicolons, 2-space indent
- TypeScript (.ts/.tsx): Semicolons, 2-space indent
- Commits: Conventional format (feat:, fix:, docs:, chore:)

### Key Commands
```bash
npm test                    # Before committing
./scripts/checkpoint.sh     # Save work
./scripts/rotate-memory.sh  # Keep memory lean
```

### Protected Files (Never Delete)
- AGENT_CONTEXT.md, .cursorrules
- prompts/agents/memory/*.md
- prompts/agents/roles/*.md
- docs/standards/*

### What NOT to Do
- Add unrequested features
- Refactor unrelated code
- Delete protected files
- Create feature branches (work on main)
- Split fenced output blocks

---

## Session End Checklist

Before ending:
1. Run `npm test`
2. Commit: `git add -A && git commit -m "<type>(<scope>): <desc>"`
3. Push: `git push origin main`
4. If significant work: Update memory file (keep brief!)

---

## Agent Identity

End responses with role in caps: `(CLI AGENT)`, `(WEBSITE AGENT)`, etc.

---

## Token Efficiency Rules

1. **Memory files**: Keep sessions brief (5-10 lines each)
2. **Don't read files you don't need**
3. **Batch file reads** when possible
4. **Skip verification questions** in slim mode
5. **No verbose acknowledgments** - 3 lines max
```

---

## Task 3: Consolidate Governance Files

### Goal
Eliminate CLAUDE.md entirely, merge essential content into .cursorrules.

### Implementation

**Step 1: Archive CLAUDE.md**
```bash
mv CLAUDE.md docs/archive/CLAUDE-v2.3-archived.md
```

**Step 2: Trim AGENT_CONTEXT.md to essentials only**

Keep only:
- Project Vision (2 lines)
- Architecture Overview (the directory tree)
- Key Flows (3 bullet points)
- Coding Standards (condensed table)
- Protected Files list
- Agent Identity section

Remove:
- Duplicate bootstrap instructions (now in .cursorrules)
- Verbose explanations
- Example code blocks
- Script listings (reference docs/scripts/ instead)

**Target size: 4-5KB (down from 12KB)**

**Step 3: Create reference doc for rarely-needed content**

Move verbose content to `docs/governance/FULL_CONTEXT.md` for when [full] mode is used.

---

## Verification

After implementation, verify:

1. **Memory file sizes:**
   ```bash
   wc -c prompts/agents/memory/*_MEMORY.md | sort -n
   ```
   All should be < 15KB

2. **Governance file sizes:**
   ```bash
   wc -c .cursorrules AGENT_CONTEXT.md
   ```
   Total should be < 15KB (down from 31KB)

3. **Bootstrap token count:**
   - Slim mode: < 3,000 tokens
   - Full mode: < 10,000 tokens

---

## Success Metrics

| Metric | Before | After | Savings |
|--------|--------|-------|---------|
| .cursorrules | 7.6KB | 3KB | 60% |
| AGENT_CONTEXT.md | 12.1KB | 5KB | 59% |
| CLAUDE.md | 11.2KB | 0KB | 100% |
| Avg memory file | 20KB | 8KB | 60% |
| Bootstrap reads | 6-8 files | 1-2 files | 75% |
| Est. tokens/session | 15,000 | 4,000 | 73% |

---

## Deliverables

1. [ ] `scripts/rotate-memory.sh` - Memory rotation script
2. [ ] `scripts/manage-memory-archives.sh` - Archive retention management
3. [ ] `output/shared/archive/memory/` - Centralized archive location
4. [ ] Updated `.cursorrules` - Slim-first bootstrap
5. [ ] Trimmed `AGENT_CONTEXT.md` - Essential content only
6. [ ] Archived `CLAUDE.md` - Moved to docs/archive/
7. [ ] `docs/governance/FULL_CONTEXT.md` - Verbose content for [full] mode

---

## Next Agent

After completing, hand off to Testing Agent to verify slim mode works correctly across different agent types.

